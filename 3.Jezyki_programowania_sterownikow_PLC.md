# 3. Języki programowania sterowników PLC



## 3.1 Wstęp



## 3.2 FBD


**The Function Block Diagram (FBD)** is a graphical language for programmable logic controllers. It can describe the function between input variables and output variables. To define how output variables depend on the input variables we need to use **function blocks**. Connecting the blocks is often as simple as streching a line between them. For the purpose of this project we will examples from the 'LOGO!Soft' program from SIEMENS used during academic studies. Below is the picture of the PLC which uses said software.

![LOGO! SIEMENS](https://i.imgur.com/HCzraLV.jpg)
*A picture of the PLC which uses 'LOGO!'*

# Function blocks

In FBD all functions are put into function blocks. They all have one or more inputs and outputs. The function of the block is the relation between the state of its inputs and outputs.

![Function block](https://i.imgur.com/ImSfvM8.jpg)

The function block is illustrated with a box. In the middle of the box is often a symbol or a text. This symbol represents the actual functionality of the function block. Depending on the function there can be any number of inputs and outputs on the function block. You can connect the output of one function block to the input of another. Thereby creating a **Function Block Diagram**.

![Sample FBD](https://i.imgur.com/ddc0zyX.jpg)
*Sample FBD*

# Input and output blocks 

### Digital input

![Digital input](https://i.imgur.com/a6w7JRF.jpg)

A two-state digital input. In standard SIEMENS LOGO! there are 8 programmable digital inputs.

### Digital output

![Digital output](https://i.imgur.com/QuJsVlS.jpg)

A two-state digital output. In standard SIEMENS LOGO! there are 4 programmable digital inputs. This block also has an output which can used althogh **in some cases recursion using this block is prohibited** in LOGO!.

### LOW state input

![LOW state input](https://i.imgur.com/t1dfLVa.jpg)

A block with a single output which is always in the LOW logic state.

### HIGH state input

![HIGH state input](https://i.imgur.com/Yciu2Yv.jpg)

A block with a single output which is always in the HIGH logic state.

### Digital flag

![Digital flag](https://i.imgur.com/36I59gA.jpg)

A special block with a single input and output which can store a single bit of information such as a value of an input or output variable or a result of an operation. **This block can be used for recursion purposes!**. The default state of the flag is LOW. The defualt state overwrites the current value of the flag with each start and finish of the running program. 


### Analog input

![Analog input](https://i.imgur.com/lwoXFmg.jpg)

Works similar to its digital counterpart. In LOGO! users can use 0-10 VDC or 0-20 mA as an input signal.

### Analog output

![Analog output](https://i.imgur.com/lwoXFmg.jpg)

Works similar to its digital counterpart. In LOGO! 0-10 VDC is always an output signal.

### Analog flag

![Analog flag](https://i.imgur.com/lwoXFmg.jpg)

Works similar to its digital counterpart.

# Bit Logic Function Blocks

Users can use these blocks to form desired logic functions. All logic gates in FDB work the same as in logic circuits. If the bit logic block has unused inputs, **there are treated as nonexistent**.

### AND gate

![AND gate](https://i.imgur.com/3gAPX8I.jpg)

This block acts like a AND logic gate. Up to four inputs can be used.

| **In1** | **In2** | **In3** | **In4** | **Q** |
|:-------:|:-------:|:-------:|:-------:|:-----:|
|    0    |    0    |    0    |    0    |   0   |
|    1    |    0    |    0    |    0    |   0   |
|    0    |    1    |    0    |    0    |   0   |
|    1    |    1    |    0    |    0    |   0   |
|    0    |    0    |    1    |    0    |   0   |
|    1    |    0    |    1    |    0    |   0   |
|    0    |    1    |    1    |    0    |   0   |
|    1    |    1    |    1    |    0    |   0   |
|    0    |    0    |    0    |    1    |   0   |
|    1    |    0    |    0    |    1    |   0   |
|    0    |    1    |    0    |    1    |   0   |
|    1    |    1    |    0    |    1    |   0   |
|    0    |    0    |    1    |    1    |   0   |
|    1    |    0    |    1    |    1    |   0   |
|    0    |    1    |    1    |    1    |   0   |
|    1    |    1    |    1    |    1    |   1   |
*Truth table*

This block also has an 'edge' counterpart which can remember its previous state. It has HIGH output when all currently used inputs are HIGH but atleast one input has LOW during last cycle.

![AND edge gate](https://i.imgur.com/MJzujVI.jpg)
*AND edge gate*

### NAND gate 

![NAND gate](https://i.imgur.com/QirzKZ2.jpg)

This block acts like a NAND logic gate. Up to four inputs can be used.

| **In1** | **In2** | **In3** | **In4** | **Q** |
|:-------:|:-------:|:-------:|:-------:|:-----:|
|    0    |    0    |    0    |    0    |   1   |
|    1    |    0    |    0    |    0    |   1   |
|    0    |    1    |    0    |    0    |   1   |
|    1    |    1    |    0    |    0    |   1   |
|    0    |    0    |    1    |    0    |   1   |
|    1    |    0    |    1    |    0    |   1   |
|    0    |    1    |    1    |    0    |   1   |
|    1    |    1    |    1    |    0    |   1   |
|    0    |    0    |    0    |    1    |   1   |
|    1    |    0    |    0    |    1    |   1   |
|    0    |    1    |    0    |    1    |   1   |
|    1    |    1    |    0    |    1    |   1   |
|    0    |    0    |    1    |    1    |   1   |
|    1    |    0    |    1    |    1    |   1   |
|    0    |    1    |    1    |    1    |   1   |
|    1    |    1    |    1    |    1    |   0   |
*Truth table*

This block also has an 'edge' counterpart which can remember its previous state. It has HIGH output when at least one input is in LOW state but all inputs were in HIGH state during last cycle.

![NAND edge gate](https://i.imgur.com/jWXWBix.jpg)
*NAND edge gate*

### OR gate

![OR gate](https://i.imgur.com/9cp0nO6.jpg)

This block acts like a OR logic gate. Up to four inputs can be used.

| **In1** | **In2** | **In3** | **In4** | **Q** |
|:-------:|:-------:|:-------:|:-------:|:-----:|
|    0    |    0    |    0    |    0    |   0   |
|    1    |    0    |    0    |    0    |   1   |
|    0    |    1    |    0    |    0    |   1   |
|    1    |    1    |    0    |    0    |   1   |
|    0    |    0    |    1    |    0    |   1   |
|    1    |    0    |    1    |    0    |   1   |
|    0    |    1    |    1    |    0    |   1   |
|    1    |    1    |    1    |    0    |   1   |
|    0    |    0    |    0    |    1    |   1   |
|    1    |    0    |    0    |    1    |   1   |
|    0    |    1    |    0    |    1    |   1   |
|    1    |    1    |    0    |    1    |   1   |
|    0    |    0    |    1    |    1    |   1   |
|    1    |    0    |    1    |    1    |   1   |
|    0    |    1    |    1    |    1    |   1   |
|    1    |    1    |    1    |    1    |   1   |
*Truth table*

### NOR gate

![NOR gate](https://i.imgur.com/lE9IySn.jpg)

This block acts like a NOR logic gate. Up to four inputs can be used.

| **In1** | **In2** | **In3** | **In4** | **Q** |
|:-------:|:-------:|:-------:|:-------:|:-----:|
|    0    |    0    |    0    |    0    |   1   |
|    1    |    0    |    0    |    0    |   0   |
|    0    |    1    |    0    |    0    |   0   |
|    1    |    1    |    0    |    0    |   0   |
|    0    |    0    |    1    |    0    |   0   |
|    1    |    0    |    1    |    0    |   0   |
|    0    |    1    |    1    |    0    |   0   |
|    1    |    1    |    1    |    0    |   0   |
|    0    |    0    |    0    |    1    |   0   |
|    1    |    0    |    0    |    1    |   0   |
|    0    |    1    |    0    |    1    |   0   |
|    1    |    1    |    0    |    1    |   0   |
|    0    |    0    |    1    |    1    |   0   |
|    1    |    0    |    1    |    1    |   0   |
|    0    |    1    |    1    |    1    |   0   |
|    1    |    1    |    1    |    1    |   0   |
*Truth table*

### XOR gate

![XOR gate](https://i.imgur.com/G8GJB1Y.jpg)

This block acts like a XOR logic gate. Up to four inputs can be used.

| **In1** | **In2** | **Q** |
|:-------:|:-------:|:-----:|
|    0    |    0    |   0   |
|    1    |    0    |   1   |
|    0    |    1    |   1   |
|    1    |    1    |   0   |
*Truth table*

### NOT block

![NOT block](https://i.imgur.com/rcG3KrV.jpg)

This block acts like a NOT logic block.

| **In1** | **Q** |
|:-------:|:-----:|
|    0    |   1   |
|    1    |   0   |
*Truth table*

# Timers

### On-Delay

![On-Delay](https://i.imgur.com/wnSUho0.jpg)

This block turns on the output after a delay. The delay time can be set in the 'Block Properties'.

![On-Delay timing](https://i.imgur.com/AMYE2IJ.png)
*Timing diagram*

### Off-Delay

![Off-Delay](https://i.imgur.com/t2OoM3q.jpg)

This block turns off the output after a delay. The delay time can be set in the 'Block Properties'.

![Off-Delay timing](https://i.imgur.com/inym3k9.png)
*Timing diagram*

### On-/Off-Delay

![On-/Off-Delay](https://i.imgur.com/c36Hp3F.jpg)

This block can act both like an On-Delay and Off-Delay block. Delay times can be set in the 'Block Properties'.

### Retentive On-Delay

![Retentive On-Delay](https://i.imgur.com/o6s7l2Y.jpg)

This block acts like an On-Delay block with dew diffrences. Rising edge on the trigger input will start the timer. After the timer runs out no matter the changes in trigger input, the output value will remain the same until HIGH logic state will the reset input. HIGH reset input also resets the timer.

![Retentive On-Delay timing](https://i.imgur.com/M64pkwF.jpg)
*Timing diagram*

### Wiping relay (pulse output)

![Wiping relay](https://i.imgur.com/fCIrsiw.jpg)

This block releases a very short pulse output signal when enabled by HIGH state input.

![Wiping relay timing](https://i.imgur.com/DvoDjM8.png)
*Timing diagram*

### Weekly Timer

![Weekly Timer](https://i.imgur.com/i5Kv5Ak.jpg)

This block has a HIGH logic state output only on set days and hours. Time can obtained from computer clock or PLC clock.

![Weekly Timer config](https://i.imgur.com/obXMUWT.jpg)
*Weekly timer config*

### Yearly Timer

![Yearly Timer](https://i.imgur.com/J4XA7IV.jpg)

This block has a HIGH logic state output only between set dates each year. Config screen below.

![Yearly Timer config](https://i.imgur.com/yB7B2ZC.jpg)
*Weekly timer config*

# Other blocks

### Up/Down counter

![Up/Down counter](https://i.imgur.com/WyJcgha.jpg)

This block can both as a up and down counter as the name suggest. There are four inputs. Counting from top the names are: 'R', 'Cnt', 'Dir' and 'Par'. Explanation what these inputs do is in the table below.

| Name of the input |                                                                                       Description                                                                                      |
|:-----------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|         R         |                                                            Resets the value counted by the block and sets the output to LOW.                                                           |
|        Cnt        |                                                         Each rising edge triggers the change to the value counted by the block.                                                        |
|        Dir        |                               If this input is in the HIGH state then the counter counts upwards. If this input is LOW then the counter counts downwards.                              |
|        Par        | If the ON and OFF parameters are set this input can provide: - blocking the change and viewing of the parameters - remembering the output value even after turning of the power supply |

Moreover, there are two key parameters to be specified by the user - the 'ON' and 'OFF' values. **If the ON parameter is higher or equal to the OFF value then:**
- output is HIGH if the counted value (the value countend by the block) >= ON
- output is LOW if the counted value < OFF

**If ON < OFF then output is HIGH when ON <= counted value < OFF.**

![Up/Down counter](https://i.imgur.com/Co1CjaY.jpg)
*Config screen*

### PI controller

![PI controller](https://i.imgur.com/UMhuCIP.jpg)

In LOGO! there is a possibility to use also more advanced blocks like a PI controller. The setpoint (desired value of the output) and gain can be set in the 'Block Properties'. The controler can work both in manual and auto mode.

![PI controller config](https://i.imgur.com/TS2kJG4.jpg)
*Config screen*

### RS flip flop (Latching Relay)

![RS](https://i.imgur.com/qCKXtZA.jpg)

The bistable block can 'store' 1 bit of memory as its state: HIGH or LOW. The current state of the block is also its output signal. Here is how the block can be represented by previously described blocks.

![RS explained](https://i.imgur.com/9f5LARp.jpg)

The block has three inputs (from the top): 'S' set, 'R' reset and 'Par'. 'S' is the value we want the state of the block to become. 'R' is an asynchronous reset which will set the state of the block and its output to LOW.

| S | R | output |
|:-:|:-:|:------:|
| 0 | 0 |    X   |
| 1 | 0 |    1   |
| 0 | 1 |    0   |
| 1 | 1 |    0   |
*Table explaining how this block changes its state*

### Shift register

![Shift register](https://i.imgur.com/TtkEI0U.jpg)

This block stores upto eight bits of the signal (storage bits are named from S1 to S8) and has a shift mechanic which shifts the input signal. Counting from the top there are 5 inputs. 'In' is the input signal being shifted. 'Trg' is triggered by the rising egde and moves the register's bits. 'Dir' decides the direction of the shifting (HIGH is from S8 to S1, LOW is from S1 to S8). Finally 'Par' requires the number of the storage bit that will be treated as the block's output.

# *FBD practical examples*




## 3.3 LD (LAD)

### General:
The Ladder Diagram, also known as LAD or LD is a graphics-oriented programming language, used to create software for programmable logic controllers (PLCs) used in industrial control applications. It’s used for documentation and implementation of software in manufacturing and process control. Its structure resembles that of an electric circuit. Its name derives from the graphic representation of the program resembling ladders. LD is standardized in IEC 611131-3.

LD was originally created to allow engineers to develop software without additional training in a programming language, hence its relative simplicity of development and structure. It is also why LD resembles in its presentation an electric circuit.

### Structure:
LD allows the construction of simple logical switches and more complex networks, when the programs call for sequential control over a process. Its structure consists of a series of networks, represented by horizontal lines, which run between two vertical lines – power rails, which run on the left and right side of the screen. A network can consist of contacts and connecting lines. One rung of the ladder allows the use of 29 contacts.

![p2.1](https://plc4me.com/wp-content/uploads/2020/01/Untitled.png)

Ladder Logic is a rule-based language rather than a procedural one, which means that select rules are executed when activated if select conditions are met. Because of this, during execution of a program the rules are typically executed sequentially in a loop. Proper use of PLCs requires understanding of the logic behind the order of execution of particular rules (“rungs” on the ladder), along with the limitations that come with such an execution, such as hazards. The PLC executes the program one ‘ladder rung’ at a time.

### Components:

The main components in the language are connections between checkers and actuators. 

![p2.2](https://industrial-electronics.com/images/ptee_2-11.jpg)

*Some of the commonly used components in LAD*

The actuators (coils) represent the output signal. If a path can be traced from the left power rail to a select actuator, then the “rung” of the ladder is true (and by analogy, the coil is energized) and the actuator provides output 1. If no path can be traced (and the coil is deenergized), the output is 0. 

Coils can be:
* normally open
* normally closed
* type set
* type reset
* detecting a rising slope
* detecting a falling slope
* a continuation coil
* with a memory 

The checkers (contacts) also represent bits in the circuit. They make and break circuits that connect the power rails to the coils. A normally open checker will only close the circuit when its corresponding coil is energized.

Checkers can be:
* normally open
* normally closed
* a continuation checker

System variables can be used with coils and contacts to create things like generators, or variables which change after starting the program.

Additionally, LAD allows the use of function blocks. Such a block executes a specified function. It will receive input signals from the left and provide an output to its right. The output can be used later to control other components. Those function blocks can be, for example:
* adders
* counters
* multipliers
* timed relays

![p2.3](https://forum-automation-uploads.sfo3.cdn.digitaloceanspaces.com/original/1X/faee9169d3e06ded1636060610353e3ecf79d71e.png)

*Example of a timer*

### Variables:
LD allows the use of following, basic types of variables:
* BOOL - a binary value
* INT - an integer number, usually takes up 8, 16 or 32 bits
* REAL - a real number, usually takes up 32 bits
* STRING - a sequence of characters

Particular hardware will use those types of variables, however there might be slight differences in, for example, their names e. g. a boolean value may be named as a binary value.

## 3.4 IL - instruction list

### General:
IL language is very rarely used nowadays. It is an effect of high complexity and need for handling low-level events similar to assembly language. Because of these disadvantages IL is very hard to learn and understand for people with no experience in programming or computer/CPUs architecture. Many PLC programmers bypass this language in favor of LD (3.3) and ST(3.5).
IL code is also very hard to read, so it is also very hard to debug and maintain. In IL programmer is able to conduct complex mathematical operations with usage of low computing power but it takes a lot of knowledge and time to write suitable code for it.
Instruction list language is very powerful because of writting operations directly on memory and has the best performance among all PLC programming languages described in this repository.

### Syntax and Structure:

IL programs consist of a sequence of instructions, each represented by a line of code. Each instruction performs a specific operation or control task. The syntax of IL is usually very concise and resembles assembly language in many ways. Here are some key aspects of IL syntax:

1. Operations and functions: IL uses mnemonic codes to represent operations or functions. For example, LD (Load), OUT (Output), AND (Logical AND), etc. These mnemonics make the code easier to read and understand (for beginners it is still very hard to understand because of its assembly-like structure).
2. Operands: Instructions in IL often have operands that specify data addresses, constants, or conditions. These operands are typically represented using symbolic names or addresses, making it easier to reference specific memory locations or input/output points.
3. Comments: IL allows for the inclusion of comments in the code, which helps programmers document their logic and make the code more readable and maintainable. Comment is everything after apostrophe character


### Key Features and Concepts:

1. Bit-Level Control: IL allows for precise control at the bit level, making it suitable for applications that require managing individual sensors, actuators, and other discrete devices.

2. Branching and Control Flow: The language supports branching and decision-making with instructions like JMP (Jump) and JZ (Jump if Zero). These are used to create conditional logic.

3. Timers and Counters: IL includes instructions for working with timers (TON, TOF, TP) and counters (CTU, CTD), essential for tasks that involve time-based control and counting operations.

4. Mathematical Operations: Complex mathematical operations are possible in IL, allowing for advanced calculations and control algorithms. Those are not easy to write or read but those are very fast because of its low-level syntax.

5. Input and Output Handling: IL provides instructions for reading input states and controlling output states (as every language designed for programming PLC).


### Advantages of IL:

* Performance: It provides direct control at the bit level, making it efficient for tasks requiring precise timing and control.

* Portability: IL code can often be easily transferred between different PLC brands and models, as it adheres to the IEC 61131-3 standard.

* Flexibility: It can handle a wide range of control tasks, from basic logic operations to complex mathematical calculations.

### Disadvantages of IL:

* Complexity: IL language is not beginner-friendly to learn. Programmer have to understand the idea of registers, memory, etc. Instruction list is not intuitive at all.

* Time consuming: Writting simple program takes a lot of time because programmer have to handle/manage basic memory and processor operations in not effective way.

### Example for blinking diode:

    LD O0.1     'Load the current state of output O0.1
    NOT         'Invert the state (toggle)
    ST O0.1     'Store the toggled state back to output O0.1
    TON 1000    'Timer on-delay for 1000 milliseconds (1 s)

### 3.5 ST

### General:

"ST language" as it stands is a text-based PLC programming language that is syntactically comparable to C C++, so those who have studied these types of computer programming languages will have an easier time learning it than for example LD. ST is a concise language that executes quickly and can be read without much difficulty. Troubleshooting it, on the other hand, can be a more involved process since the states of variables aren’t easily discernible. This language is best for doing things like barcode parsing, looping, manipulating data, bridging the gap to machine code, complicated math, or searching data.

### Syntax and Structure:

The main element of ST are "expressions". They represent a language element that, when executed, provides a value corresponding to one of the data types defined below. An expression consists of operators and operands. An operand can be a variable, a constant, a called function, or another expression. Calculating the value of an expression involves applying operators to operands
according to the corresponding order shown below. Operators with higher priorities are executed before operators with lower priorities.

ST language operators (with corresponding order):
1. "expression" - brackets
2. "funtionName(argument list)" - calculating function value
3. "**" - exponentiation
4. "-" - Negation
5. "NOT" - Complement
6. "*" - Multiplication
7. "/" - Division
8. "MOD" - Modulo
9. "+" - Addition
10. "-" - Subtraction
11. "<, >, <=, =>" - Comparison
12. "=" - Equality
13. "<>" - Inequality
14. "&" - Logical product
15. "AND" - Boolean AND
16. "XOR" - Boolean exclusive OR
17. "OR" - Boolean OR

Types of data:
1. "BOOL" - boolean or discrete
2. "BYTE" - 8-bit bit string
3. "INT" - 16-bit integer
4. "UINT" - 16-bit unsigned integer
5. "WORD" - 16-bit bit string
6. "DINT" - 32-bit integer
7. "REAL" - 32-bit floating-point value
8. "DWORD" - 32-bit bit string
9. "LREAL" - 64-bit floating-point value
10. Structures and arrays of variables can also be used


### Key Features and Concepts:


### Advantages of ST:

* The main advantage of ST is its text-based form that is similar to other well-known programming languages such as C++ or C. That is crucial because nowadays, nearly all future engineers from all kinds of technical courses learn some kind of text-based programming language like C++ mentioned before. Therefore new technicians coming to the job market will have more tendency to learn it first, rather than spending precious hours on mastering a PLC programming language that will be completely new to them.

* Version control compatibility gives ST a huge advantage. This way of realizing a given task makes it lots easier to track every step of project realization. In any case of malfunction of the new code, we can easily get back to the previous one that we tested that it works. Today's work in major software projects heavily depends on this system.

* ST is one of the five languages supported by the IEC 61131-3 standard, designed for programmable logic controllers (PLCs). That gives it huge versatility in porting it to various platforms.   

### Disadvantages of ST:

### Examples:

A simple program that will start a motor when the start push-button is pressed and stop the motor when the stop push button is pressed.


    IF Start_PB THEN
        MOTOR_RUN_RELAY := 1;
    END_IF;

    IF Stop_PB THEN
        MOTOR_RUN_RELAY := 0;
    END_IF;

The same code with programmed in the Ladder Diagram:

![Code to control motor in Ladder Diagram](images/3.5.MotorLadder.png)
